package storage

import (
	"fmt"
	"io"
	"os"
	"path/filepath"

	"elano.fr/src/backend/models"
	"gopkg.in/yaml.v3"
)

func SaveProjectToFile(project *models.Project, path string) error {
	if project == nil {
		return fmt.Errorf("cannot save nil project")
	}

	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %q: %w", dir, err)
	}

	f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return fmt.Errorf("failed to create file %q: %w", path, err)
	}
	defer f.Close()

	encoder := yaml.NewEncoder(f)
	encoder.SetIndent(2)
	defer encoder.Close()

	header := "# DMX Controller Project Configuration\n# Generated by elano.fr/backend\n\n"
	if _, err := f.WriteString(header); err != nil {
		return fmt.Errorf("failed to write header: %w", err)
	}

	if err := encoder.Encode(project); err != nil {
		return fmt.Errorf("failed to encode project to YAML: %w", err)
	}

	if err := f.Sync(); err != nil {
		return fmt.Errorf("failed to sync file: %w", err)
	}

	return nil
}

func LoadProjectFromFile(path string) (*models.Project, error) {
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, fmt.Errorf("project file not found: %q", path)
		}
		return nil, fmt.Errorf("failed to stat file %q: %w", path, err)
	}

	const maxFileSize = 10 * 1024 * 1024
	if info.Size() > maxFileSize {
		return nil, fmt.Errorf("project file too large: %d bytes (max %d)", info.Size(), maxFileSize)
	}

	f, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("failed to open file %q: %w", path, err)
	}
	defer f.Close()

	var project models.Project
	decoder := yaml.NewDecoder(f)
	decoder.KnownFields(true)

	if err := decoder.Decode(&project); err != nil {
		if err == io.EOF {
			return nil, fmt.Errorf("project file is empty: %q", path)
		}
		return nil, fmt.Errorf("failed to decode YAML from %q: %w", path, err)
	}

	if err := validateLoadedProject(&project); err != nil {
		return nil, fmt.Errorf("invalid project in %q: %w", path, err)
	}

	if project.Fixtures == nil {
		project.Fixtures = []models.Fixture{}
	}
	if project.Presets == nil {
		project.Presets = []models.Preset{}
	}
	if project.Shows == nil {
		project.Shows = []models.Show{}
	}

	return &project, nil
}

func validateLoadedProject(p *models.Project) error {
	if p.ID == "" {
		return fmt.Errorf("project ID is missing")
	}
	if p.Name == "" {
		return fmt.Errorf("project name is missing")
	}
	if p.USBInterface == "" {
		return fmt.Errorf("USB interface is missing")
	}

	for i, f := range p.Fixtures {
		if f.ID == "" {
			return fmt.Errorf("fixture[%d] ID is missing", i)
		}
		if f.Name == "" {
			return fmt.Errorf("fixture[%d] name is missing", i)
		}
		for j, ch := range f.Channels {
			if ch.Name == "" {
				return fmt.Errorf("fixture[%d].channel[%d] name is missing", i, j)
			}
			if ch.Min < 0 || ch.Max > 255 || ch.Min > ch.Max {
				return fmt.Errorf("fixture[%d].channel[%d] has invalid range", i, j)
			}
			if ch.ChannelAddress < 1 || ch.ChannelAddress > 512 {
				return fmt.Errorf("fixture[%d].channel[%d] has invalid address", i, j)
			}
		}
	}

	for i, pr := range p.Presets {
		if pr.ID == "" {
			return fmt.Errorf("preset[%d] ID is missing", i)
		}
		if pr.Name == "" {
			return fmt.Errorf("preset[%d] name is missing", i)
		}
		for j, ch := range pr.Channels {
			if ch.DMXAddress < 1 || ch.DMXAddress > 512 {
				return fmt.Errorf("preset[%d].channel[%d] has invalid DMX address", i, j)
			}
			if ch.Value > 255 {
				return fmt.Errorf("preset[%d].channel[%d] has invalid value", i, j)
			}
		}
	}

	for i, s := range p.Shows {
		if s.ID == "" {
			return fmt.Errorf("show[%d] ID is missing", i)
		}
		if s.Name == "" {
			return fmt.Errorf("show[%d] name is missing", i)
		}
		if len(s.Steps) == 0 {
			return fmt.Errorf("show[%d] has no steps", i)
		}
		for j, step := range s.Steps {
			if step.PresetID == "" {
				return fmt.Errorf("show[%d].step[%d] preset ID is missing", i, j)
			}
			if step.Duration < 0 {
				return fmt.Errorf("show[%d].step[%d] has negative duration", i, j)
			}
			if step.FadeMS < 0 {
				return fmt.Errorf("show[%d].step[%d] has negative fade time", i, j)
			}
		}
	}

	return nil
}

func ExportProjectJSON(project *models.Project, path string) error {
	return fmt.Errorf("JSON export not yet implemented")
}

func ImportProjectJSON(path string) (*models.Project, error) {
	return nil, fmt.Errorf("JSON import not yet implemented")
}
